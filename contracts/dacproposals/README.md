# dacproposals

The eosdac worker proposal contract

Worker proposals are key to the running of a DAC. The contract will facilitate the exchange of a product or service in return for a payment.

Proposals are generated by the worker seeking to perform the service in exchange for a payment. Multiple worker proposals can be created for multi-milestone projects.

Requests can be generated by the DAC when a specific service is required, it will be entered into the database but will not have a specific account or payment attached. Workers will tender for the job and will submit their own sub-proposal for each request.

## Tables

### Proposal

- id (uniqid) - A unique identifier assigned to the proposal when first created.
- proposer (account_name) - The account providing the service
- arbitrator (account_name) - This will be an account which can be present in the 3 way signature in the claim action. If the two parties in the worker proposal disagree on the deliverables then this account will be able to sign the claim action to release the funds or return them to the DAC.
- content_hash (string) - A hash of the content to ensure the proposal description is not tampered with.
- pay_amount - Amount of the payment for this proposal
- state - The current state of the proposal
- expiry - A timepoint when the proposal should expire for being considered by the custodians.
- job_duration - the expected time in seconds to complete the work. This is used to determine the duration of the escrow lock-up time once the proposal is approved for work.
- category - This is a free integer that can be used to help group proposals and facilitate the category delegation voting.

### ProposalVote

- vote_id (uniqid) - The unique ID for the vote
- voter (account_name) - The account name of the voter
- vote (optional int8) - This is optional since a vote could also delegate vote to someone else.
- proposal_id - (optional name) - This is optional to link a vote directly to a proposal since a vote could also be a category delegate vote without a proposal id.
- category_id - (optional int64) - This is optional to link a vote directly to a category since a vote could also be a direct proposal vote without a category id.
- delegatee (optional name) - This is to delegate a vote to another custodian but not all votes will delegate so this field is optional.
- comment_hash (optional string) - this is optional but allow for a comment to associated with a vote if a custodian wants to attach further context to their vote that can be tracked on the blockchain.

### config

- proposal_threshold (uint16) - number of required approval votes to allow a proposal to commence work.
- finalize_threshold (uint16) - number of required approval votes to allow a proposal to complete work and get paid.
- approval_duration (uint32) - The time in seconds that a proposal has to get approved by custodians before it is expired.

## Actions

### createprop

This allows a user to create a proposal. To create a proposal a user must also lock a bond in eosDAC tokens. This bond will be lost if the proposal is marked as spam (defined by a 100% no vote). If no worker attribute is provided and the type is REQUEST then it will require a privileged account to create.

### voteprop

Vote for a proposal, this can either be `abstain` for abstain vote, `vote_approve` or `vote_deny` for work proposal. Once enough approval votes have been given, the proposer can start work on the proposal using the `startwork` action. At the time of voting the votes count for the given proposal are also updated so that if there are enough votes to approve a new proposal the state will be updated to `ProposalStateHas_enough_approvals_votes`. The benefit of these extra states is that the current voting state of the proposal can be read directly from the chain state without having to count the votes each time a query is needed or replicating the vote counting algorithm off-chain (which could be a source of business logic inconsistency).

### votepropfin

Vote for a proposal once it is finalized. Votes can either be `abstain` for abstain vote, `vote_approve` or `vote_deny`.

### delegatevote and delegatecat

Some proposals are specific to a particular domain that some custodians may not be comfortable to judge on and therefore would like to delegate their vote to another chosen custodian. While this could be done off chain through discussion and collusion a more reliable and transparent approach is to allow a custodian to delegate their vote for a particular proposal to another custodian. This can be done at a proposal level or at a category level for all present and future proposals that a match a given category. If a custodian has delegated a category and proposal to different custodians that happen to match a given proposal the proposal delegation will take priority over the category delegation. A custodian may override a delegated vote for a proposal by either voting directly for a proposal or delegating to another custodian.
eg. There is a proposal with id 123 and category 5. Custodian A has delegated all proposals with category 5 to custodian B and then delegated for proposal id 123 to custodian C. In this case the vote from Custodian A will be delegated to custodian C.

### undelegateca

Since the category delegation of votes is persistant a custodian would need to undelegate their category vote using this action. After this no delegation would occur for this category for this particular custodian. The equivalent action for undelegating a vote for a proposal is not necessary as descirbed in the previous section.

### startwork

This action must be called by the proposer to signal that they are starting work on a proposal. This will only succeed if there are sufficient votes for the given proposal to approve the beginning of work by checking the current votes (including delegated votes and delegated categories for this proposal). Upon success this action will initialise an escrow entry locking up the required payment amount for the worker, also assigning the nominated arbitrator for the escrow if arbitration is ever required for the proposal via a deferred transaction. Finally the proposal is moved to a `ProposalStateWork_in_progress` state while the worker is actively working on the proposal.

### completework

When the worker has completed their work it must be assessed by the custodians to decide if the work has been fullfilled has per the agreed and approved worker proposal. In order to move into this state the worker needs to signal that they have completed the work by calling the `completework` action. This can only be be called by the worker when the proposal is in the `Work_in_progress` state. On success the proposal will be moved to the `Pending_finalize` state and wait the custodians to vote to approved or deny the finalizing of the proposal.

### finalize

While a proposal is in the `Pending_finalize` state the proposal's completed work needs to be assessed by the elected custodians to determine if the work is completed as agreed by the worker proposal. At this point the custodians would need to vote again on the worker proposal with either `finalize_approve` or `finalize_deny`. Once enough votes have been placed to approve the finalize (determined by the config settings for the DAC) the will be able to call the `finalize` action. On a successful call to this action the funds for the work will be transferred from the associated escrow entry to the worker.

### dispute

During the time when the proposal is in `Pending_finalize` state a worker may find that their proposal is not being approved when then they believe it should be. The custodians may have either not voted or have voted with enough of a deciding vote to deny the finalize of the proposal. At this point the worker could call the `dispute` action which could put the proposal into the `ProposalStateInDispute` state. Then only the chosen arbitrator can step in to resolve the matter.

### arbapprove and arbdeny

When a proposal is in the `ProposalStateInDispute` state the nominated arbitrator for the proposal would be required to assess the proposal and the work that has been said to be completed and make a determination of whether the payment should be paid or denied. The arbitrator would then be the only actor in the proposal/escrow arrangement that has the power to either call a transaction with `approve` to the escrow and `arbapprove` to the proposals contract to release the escrowed funds to the worker, or call a transaction with `disapprove` to the escrow and `arbdeny` to the proposals contract to release the escrowed funds back to the DAC. Note: The significance of calling the actions to both the escrow and proposals contracts within a transaction rather than calling an inline action from the proposals to the escrow contract is that the inline option would require giving the `eosio.code` permission on the proposals contract the same privialeges as the arbitrator's active permission which would be insecure and not scalable for multiple arbitrators in the proposals system.

### cancel

At any time a proposer for a worker proposal may choose to cancel the worker proposal. If this is before the worker has started any work on the proposal then this would remove the proposal and any associated votes with the proposal from the contract. If the worker has already commenced work on the proposal after they have been approved to work on it. The proposal and votes will be cleaned up but the funds that have been locked in the escrow contract for the proposal will remain locked until the escrow has expired. The the custodians will need to call the refund action after expiry to recover the funds from escrow.
